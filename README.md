# 简单电商项目

### 1. 需求分析

业务背景：电商业务中，需要给电商app设计一个用户钱包，用户可以往钱包中充值，购买商品时用户可以使用钱包中的钱消费，商品申请退款成功后钱会退回钱包中，用户也可以申请提现把钱提到银行卡中

用程序实现如下api接口

1. 查询用户钱包余额
2. 用户消费100元的接口
3. 用户退款20元接口
4. 查询用户钱包金额变动明细的接口



### 2. 接口设计

#### 1. 查询用户钱包余额

用户余额单独存入redis，方便操作，获取个人信息时会自动从redis获取个人余额

余额会经常修改，因此单独存入redis，并且，每次系统启动前需要预热下用户余额的缓存，防止发生缓存不一致的情况

![截屏2023-04-30 15.24.16](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-04-30%2015.24.16.png)

其中balance就是余额了



#### 2. 用户消费100元的接口

该接口就是用户购买商品，只需传递商品的id即可

##### 整体流程：

- 1. 获取用户与商品信息

- 2. 获取订单id

- 3. 执行lua脚本

- 4. 判断结果

    不为0，下单失败

- 5. 下单成功，创建消息队列

这里生成的订单id是使用redis实现的分布式**全局唯一ID生成器**

##### 其中lua脚本的执行步骤如下：

- 1. 判断库存是否充足
- 1.1库存不足
- 1.2库存充足
- 2. 判断用户余额是否足够
- 2.1 余额不够
- 2.2余额充足
- 3. 扣减库存
- 4. 扣减余额

其中使用lua脚本的主要原因是使用lua脚本可以实现**原子操作**，并且该脚本都是操作redis缓存的，速度很快，很难成为瓶颈

##### 创建订单的消息队列

很明显这个接口的瓶颈是对数据库的增改，而购买商品接口通常会在短时间内集中大量的用户请求，如果使用传统的请求-响应模式来处理这些请求，很容易造成系统的瓶颈，导致系统崩溃或者响应时间过长。而使用消息队列来处理秒杀活动的请求，则可以有效地解决这个问题。

这里使用**高可用**的消息中间件-RabbitMQ，相比JVM的阻塞队列有很多优势

接口响应如下：

![截屏2023-04-30 15.38.29](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-04-30%2015.38.29.png)

使用jemeter压测的结果，可以看到达到很好的削峰的效果，并且接口响应特别快

![截屏2023-04-30 15.51.59](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-04-30%2015.51.59.png)

![截屏2023-04-30 16.00.38](https://typora-1312272916.cos.ap-shanghai.myqcloud.com//img%E6%88%AA%E5%B1%8F2023-04-30%2016.00.38.png)

#### 3. 用户退款20元的接口

##### 重复退款

而退款的接口，主要的安全问题是用户重复退款。使用redisson的分布式锁就能很好的解决

使用订单号来作为锁的标识







#### 4. 查询用户钱包金额变动明细的接口

这里通过消息队列也可以很好的实现：





